"use strict";let settings,defaults={mode:"sphere",molecular:!0,biradical:!0},api={run(t){try{let e=core.applySettings(t);if(!0!==e)return e}catch(t){return t.message}return core.run()}};self.onmessage=function({data:{method:t,data:e}={}}){"function"==typeof api[t]&&self.postMessage({method:t,data:api[t](e)})};let core={applySettings(t){if(t=Object.assign({},defaults,t),!Number.isInteger(t.hCount)||t.hCount<1)return`A number of H atoms to be injected is incorrect: ${t.hCount}`;if(!t.sphere||!t.sphere.r)return"Wrapping sphere parameters are missed";let e=t.captureDistances,s=t.structure.atoms.find(t=>!e.has(t.el));return s?`Capture distance is not specified for ${s.el}`:((settings=t).sqrDistances=new Map([...e].map(([t,e])=>[t,e*e])),settings.lastMol=settings.structure.atoms.reduce((t,e)=>Math.max(t,e.mol),0),!0)},run(){let{molecular:t,hCount:e,sphere:s,captureDistances:r,structure:n}=settings,i="hemisphere"===settings.mode,a=0,o={method:"progress",data:0};for(;a<e;){let n=this.getRndPointOnSphere(s),l=this.getRndPointOnSphere(s);i&&(n.z=Math.abs(n.z));let u=this.getCapturingAtom(n,l);if(!u)continue;let c={cx:u.x,cy:u.y,cz:u.z,r:r.get(u.el)},h=this.lineSphereCrossPoints(c,n,l);if(!h)continue;let p=this.sqrDistance(h[0],n)<this.sqrDistance(h[1],n)?h[0]:h[1];t?(this.adhereHH(p),a+=2):(this.adhereH(p),a++),o.data=100*a/e,self.postMessage(o)}return n},adhereH({x:t,y:e,z:s}){settings.structure.atoms.push({el:"H",x:t,y:e,z:s,mol:++settings.lastMol})},adhereHH({x:t,y:e,z:s}){let r=++settings.lastMol,n=this.getRndPointOnSphere({cx:t,cy:e,cz:s,r:settings.rHH/2}),i={x:2*t-n.x,y:2*e-n.y,z:2*s-n.z},a=settings.structure.atoms.push({el:"H",x:n.x,y:n.y,z:n.z,mol:r},{el:settings.biradical?"H1":"H",x:i.x,y:i.y,z:i.z,mol:r});settings.structure.bonds.push({iAtm:a-2,jAtm:a-1,type:"s"})},getCapturingAtom(t,e){let s=settings.sqrDistances,r=null,n=1/0;for(let i of settings.structure.atoms)if(this.pointToLineSqrDistance(i,t,e)<=s.get(i.el)){let e=this.sqrDistance(i,t);(!r||n>e)&&(r=i,n=e)}return r},sphericalToCartesian(t,e,s){let r=t*Math.sin(e);return{x:r*Math.cos(s),y:r*Math.sin(s),z:t*Math.cos(e)}},sqrDistance(t,e){let s=t.x-e.x,r=t.y-e.y,n=t.z-e.z;return s*s+r*r+n*n},pointToLineSqrDistance(t,e,s){let r=[s.x-e.x,s.y-e.y,s.z-e.z],n=[t.x-s.x,t.y-s.y,t.z-s.z],i=[n[1]*r[2]-r[1]*n[2],n[0]*r[2]-r[0]*n[2],n[0]*r[1]-r[0]*n[1]];return(i[0]*i[0]+i[1]*i[1]+i[2]*i[2])/(r[0]*r[0]+r[1]*r[1]+r[2]*r[2])},lineSphereCrossPoints({cx:t,cy:e,cz:s,r:r},n,i){let{x:a,y:o,z:l}=n,u=i.x-a,c=i.y-o,h=i.z-l,p=a-t,g=o-e,m=l-s,d=u*u+c*c+h*h,y=2*(u*p+c*g+h*m),z=y*y-4*d*(p*p+g*g+m*m-r*r);if(z<0)return null;let x=Math.sqrt(z),f=(-y+x)/(2*d),M=(-y-x)/(2*d);return[{x:u*f+a,y:c*f+o,z:h*f+l},{x:u*M+a,y:c*M+o,z:h*M+l}]},getRndPointOnSphere({cx:t,cy:e,cz:s,r:r}){let n=this.sphericalToCartesian(r,Math.random()*Math.PI,2*Math.random()*Math.PI);return n.x+=t,n.y+=e,n.z+=s,n}};